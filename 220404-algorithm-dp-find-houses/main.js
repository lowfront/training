/*
"""
[1,2,3,1]
12x
13
14x
23x
21
31x

[1,2,3,4,5,6,7,8,9,10]
13
135
1356
13579
136
1368
137
1379
138
139
14
146
1468
15
157
1579
16
168
17
179
18
19

각 숫자별순으로 뽑아서 조합할 수 있는 두자리 수를 조합
순서 상관없으니 왼쪽에서 오른쪽으로만
1,2...1,9
2,4...2,9
...
7,9...7,10
8,10

두자리수에서 조합할 수 있는 세자리 수 조합... 만 보면 백트래킹으로도 가능하겠으나.
DP개념으로 생각했을 때 점화식을 생각해보면, 현재 터는 집에서 먼저 전에 터는 집을 터해서 터는 경우를 계산할 수 있음
즉 N번째 터는 집에서의 총 수익은
첫번째 집부터 N-2번째 집까지 수익들을 더 한 값이 됨

"""

def solution(money):
    l = [set() for i in money]
    l[0].add(money[0])
    l[1].add(money[1])
    
    for i in range(2, len(money)):
        for j in range(0, (i - 2) + 1):
            for k in l[j]:
                l[i].add(k + money[i])
    return max([max(i) for i in l])
"""
이렇게 하면 마지막집과 첫번째집 연속을 방지할 수 없음
"""
*/